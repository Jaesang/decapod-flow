apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: tks-lma-federation
  namespace: argo
spec:
  entrypoint: deploy
  arguments:
    parameters:
    - name: site_name
      value: "hanu-reference"
    - name: app_name
      value: "lma"
    - name: label
      value: "hanu-app1"
    - name: repository_url
      value: "https://github.com/openinfradev/decapod-manifests"
  volumes:
  - name: tks-proto-vol
    configMap:
      name: tks-proto
  templates:
  - name: deploy
    steps:
    - - name: installApps
        template: createApps
    - - name: updateInfo
        template: updateToTksInfo
        arguments:
          # These params should be moved to global argument? #
          parameters:
          - name: tks_info_host
            value: "127.0.0.1"
          - name: cluster_id
            value: "6abead61-ff2a-4af4-8f41-d2c44c745de7"
          - name: appgroup_id
            value: "abbead61-ff2a-4af4-8f41-d2c44c745de7"
          - name: thanos_sc_ep
            value: "thanos-sidecar.clusterX"
    - - name: collectEndpoints
        template: collectEndpoints
        arguments:
          # These params should be moved to global argument? #
          parameters:
          - name: tks_info_host
            value: "127.0.0.1"
          - name: cluster_id
            value: "6abead61-ff2a-4af4-8f41-d2c44c745de7"
          - name: app_group_id
            value: "abbead61-ff2a-4af4-8f41-d2c44c745de7"
          - name: cur_endpoint
            value: "thanos-sidecar.clusterX"
    - - name: updateSiteYaml?
        template: updateSiteYaml
        # add parameter here #
        #
        #
        #

  - name: createApps
    dag:
      tasks:
      - name: operator
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "prometheus-operator", "namespace": "lma" },
                { "path": "eck-operator", "namespace": "elastic-system" },
                { "path": "fluentbit-operator", "namespace": "lma" }
              ]
        dependencies: []
      - name: logging
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "eck-resource", "namespace": "lma" },
                { "path": "fluentbit", "namespace": "lma" },
                { "path": "kubernetes-event-exporter", "namespace": "lma" }
              ]
        dependencies: [operator]
      - name: prepare-lma
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "thanos-config", "namespace": "lma" }
              ]
        dependencies: [operator]

      - name: prometheus
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "prometheus", "namespace": "lma" },
                { "path": "kube-state-metrics", "namespace": "lma" },
                { "path": "prometheus-process-exporter", "namespace": "lma" },
                { "path": "prometheus-pushgateway", "namespace": "lma" },
                { "path": "prometheus-node-exporter", "namespace": "lma" },
                { "path": "prometheus-adapter", "namespace": "lma" },
                { "path": "addons", "namespace": "lma" }
              ]
        dependencies: [prepare-lma]

      - name: federation
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "thanos", "namespace": "lma" }
              ]
        dependencies: [prometheus,logging]

      - name: grafana
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "grafana", "namespace": "lma" }
              ]
        dependencies: [federation]

  #########################################################
  # Try to make this as separate workflow template so that
  # this can be used for service-mesh, too
  #########################################################
  - name: updateToTksInfo
    inputs:
      parameters:
      - name: tks_info_host
      - name: app_group_id
      - name: thanos_sc_ep
      # add param 'app_group_type' here? (See above comment) #
      #
    script:
      image: centos/python-38-centos7
      command: ["python"]
      env:
      - name: PYTHONPATH
        value: "/opt/protobuf/:/opt/rh/rh-python38/root/lib/python3.8/site-packages/:/opt/app-root/lib/python3.8/site-packages/"
      volumeMounts:
      - name: tks-proto-vol
        mountPath: "/opt/protobuf"
        readOnly: true
      source: |
        import subprocess
        import sys

        subprocess.check_call([sys.executable, "-m", "pip", "install",
        "grpcio", "protobuf"])

        import google.protobuf
        import grpc
        import info_pb2
        import info_pb2_grpc
        import common_pb2
        import common_pb2_grpc

        ip = "{{inputs.parameters.tks_info_host}}"
        port = 9111 # if not specified
        addr = "%s:%d" % (ip, port)
        print("tks-info addr: %s" % addr)

        with grpc.insecure_channel(addr) as channel:
            cl_stub = info_pb2_grpc.ClusterInfoServiceStub(channel)
            app_stub = info_pb2_grpc.AppInfoServiceStub(channel)

            res = app_stub.UpdateAppGroupStatus(info_pb2.UpdateAppGroupStatusRequest(app_group_id="{{inputs.parameters.app_group_id}}", status=common_pb2.APP_GROUP_RUNNING))
            print("Response code from UpdateAppGroupStaus: %d" % res.code)

            res = app_stub.UpdateApp(info_pb2.UpdateAppRequest(app_group_id="{{inputs.parameters.app_group_id}}", app_type=common_pb2.PROMETHEUS, endpoint="{{inputs.parameters.thanos_sc_ep}}", metadata="{}"))
            print("Response code from UpdateApp: %d" % res.code)


  - name: collectEndpoints
    inputs:
      parameters:
      - name: tks_info_host
      - name: cluster_id
      - name: app_group_id
      - name: cur_endpoint
      env:
      - name: PYTHONPATH
        value: "/opt/protobuf/:/opt/rh/rh-python38/root/lib/python3.8/site-packages/:/opt/app-root/lib/python3.8/site-packages/"
      volumeMounts:
      - name: tks-proto-vol
        mountPath: "/opt/protobuf"
        readOnly: true
      source: |
        import subprocess
        import sys

        subprocess.check_call([sys.executable, "-m", "pip", "install",
        "grpcio", "protobuf"])

        import google.protobuf
        import grpc
        import info_pb2
        import info_pb2_grpc
        import common_pb2
        import common_pb2_grpc

        endpointMap = {}

        ip = "{{inputs.parameters.tks_info_host}}"
        port = 9111 # if not specified
        addr = "%s:%d" % (ip, port)
        print("tks-info addr: %s" % addr)

        with grpc.insecure_channel(addr) as channel:
            cl_stub = info_pb2_grpc.ClusterInfoServiceStub(channel)
            app_stub = info_pb2_grpc.AppInfoServiceStub(channel)

            res = cl_stub.GetCluster(info_pb2.GetClusterRequest(cluster_id="{{inputs.parameters.cluster_id}}"))

            print("Response from GetCluster: ")
            print(res.cluster)
            contract_id = res.cluster.contract_id
            csp_id = res.cluster.csp_id
            cur_cluster_name = res.cluster.name

            res = cl_stub.GetClusters(info_pb2.GetClustersRequest(contract_id=contract_id, csp_id=csp_id))
            print("Response from GetClusters: ")
            print(res.clusters)

            cluster_list = res.clusters

            # Iterate over cluster list except current cluster
            for cluster in cluster_list:
              if cluster.id != "{{inputs.parameters.cluster_id}}":
                res = app_stub.GetAppGroupsByClusterID(common_pb2.IDRequest(id=cluster.id))
                print("Response from GetAppGroupsByClusterID:")
                print(res.app_groups)

                for app_group in res.app_groups:
                  if app_group.type == common_pb2.LMA:
                    res = app_stub.GetApps(info_pb2.GetAppsRequest(app_group_id="{{inputs.parameters.app_group_id}}", type=common_pb2.PROMETHEUS))

                    # This is based on the premise that there's only one prometheus per appGroup.
                    endpoint = res.apps[0].endpoint

                    # Add this cluster's endpoint to endpoint map
                    endpointMap[cluster.name] = endpoint

             # Update current endpoint to other cluster's site-yaml #
             update_endpoint_to_site_yaml(cluster.name, cur_endpoint)

        def update_endpoint_to_site_yaml(cluster_name, endpoint):
            # -Need to check this throws error on error case
            # -Should mount this script to this container before workflow run
            # -Consider if this script is reusable for another task. Otherwise, just embedit here
            output = subprocess.check_output("/opt/scripts/updateEndpoint.py", "--action", "add", "--cluster_name", cluster_name, "--endpoint", endpoint)
            print(output)

        ########################################
        # Finished refactoring until this line #
        ########################################












  # Embed the 'updateMultipleEndpoints.py' code here?
  # Consider making this as separate workflow template for re-use? tricky..
  - name: updateSiteYaml
    inputs:
      parameters:
      - name: curClusterName
      - name: endpointList
    script:
      image: python:alpine3.6
      command: ["python"]
      source: |
        import argparse
        import git
        import ruamel.yaml
        import os
        import sys

        print("Entering updateMultipleEndpoint script..")

        parser = argparse.ArgumentParser()
        parser.add_argument('current_cluster', type=str,
                    help="cluster name to which the endpoints are added")
        parser.add_argument('endpoint_list', type=str,
                    help="endpoint list to add")

        args = parser.parse_args()
        clusterName = args.current_cluster
        endpointListStr = args.endpoint_list

        repo = None
        config = {}

        sitePath = './decapod-site'
        siteFileName = "{}/lma/site-values.yaml".format(clusterName)
        siteFileNameFull = "{}/{}".format(sitePath, siteFileName)
        # Tested with 'robertchoi80' repo
        repoOrgName = ''

        if not os.path.isdir(sitePath):
            print("Cloning repository...")

            repo = git.Repo.clone_from("https://github.com/{}/decapod-site".format(repoOrgName), 'decapod-site')
            with repo.config_writer() as git_config:
                git_config.set_value('user', 'email', 'tks-argo@tks.com')
                git_config.set_value('user', 'name', 'TKS Argo')
        else:
            repo = git.Repo(sitePath)

        with open(siteFileNameFull, 'r') as f:
            config = ruamel.yaml.round_trip_load(f, preserve_quotes=True)

        endpointList = endpointListStr.split()
        print("endpointList: {}".format(endpointList))

        appendCount = 0
        charts = config["charts"]
        thanosChart = [chart for chart in charts if chart['name'] == "thanos"][0]

        for ep in endpointList:
            if (ep in thanosChart['override']['querier.stores']):
                print("The endpoint {} already exists.".format(ep))
            else:
                thanosChart['override']['querier.stores'].append(ep)
                appendCount += 1

        if appendCount == 0:
            print("All endpoints already exists. Exiting script..")
            sys.exit(0)

        print("After insertion: {}".format(thanosChart))

        with open(siteFileNameFull, 'w') as f:
            ruamel.yaml.round_trip_dump(config, f)

        diff = repo.git.diff(repo.head.commit.tree)
        print(diff)

        # Provide a list of the files to stage
        repo.index.add([siteFileName])

        # Provide a commit message
        repo.index.commit("add previous thanos-sidecar endpoints to '{}' cluster".format(clusterName))
        repo.remotes.origin.push()



        # Another example: https://blog.naver.com/agapeuni/222281338248
