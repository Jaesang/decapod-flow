apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: tks-lma-federation
  namespace: argo
spec:
  entrypoint: deploy
  arguments:
    parameters:
    - name: site_name
      value: "hanu-reference"
    # This should be renamed to app_group_name
    - name: app_name
      value: "lma"
    #- name: label
    #  value: "hanu-app1"
    - name: repository_url
      value: "https://github.com/openinfradev/decapod-manifests"
    ##########################
    # For updateTksInfo task #
    ##########################
    - name: tks_info_host
      value: "127.0.0.1"
    - name: cluster_id
      value: "abbead61-ff2a-4af4-8f41-d2c44c745de7"
    - name: app_group_id
      value: "abbead61-ff2a-4af4-8f41-d2c44c745de7"
  volumes:
  - name: tks-proto-vol
    configMap:
      name: tks-proto
  templates:
  - name: deploy
    steps:
    - - name: installApps
        template: createApps

      - name: updateTksInfo
        templateRef:
          name: update-tks-info
          template: updateTksApp
        arguments:
          parameters:
          # Can this be pre-determined? Or composed dynamically on deployment?
          - name: endpoints
            value: "{'PROMETHEUS': 'thanos-sidecar.cluster_id'}"
          # Need to check default value works by commenting this out.
          - name: app_group_status
            value: "APP_GROUP_RUNNING"
     
      # LMA appGroup specific task #
      - name: collectThanosScEndpoints
        template: collectThanosScEndpoints
        arguments:
          # These params should be moved to global argument? #
          parameters:
          - name: tks_info_host
            value: "127.0.0.1"
          - name: cluster_id
            value: workflow.parameters.cluster_id
          - name: app_group_id
            value: workflow.parameters.app_group_id
          # How can this be determined?
          - name: cur_endpoint
            value: "thanos-sidecar.cluster_id"
         # How to pass these outputs? Using file in filesystem?
         output:
          - cluster_list
          - inwards_endpoint_map
          - outwards_endpoint_map

      - name: updateDecapodManifestOutwards
        templateRef:
          name: update-decapod-manifest
          template: updateManifest
        arguments:
          parameters:
          - name: action
            value: "insert"
          - name: cluster_name
            value: "{{item}}"
          - name: app_group
            value: "{{workflow.parameters.app_name}}"
          - name: chart
            value: "thanos"
          - name: kv_map_str 
            value: collectEndpoints.output.outwards_endpoint_map
            ## {"querier.stores": "cur_endpoint"}
        withParam: collectEndpoints.output.cluster_list

      - name: updateDecapodManifestInwards
        templateRef:
          name: update-decapod-manifest
          template: updateManifest
        arguments:
          parameters:
          - name: action
            value: "insert"
          - name: cluster_name
            value: "{{currentCLUSTER}}"
          - name: app_group
            value: "{{workflow.parameters.app_name}}"
          - name: chart
            value: "thanos"
          - name: kv_map_str
            value: collectEndpoints.output.inwards_endpoint_map
            ## {"querier.stores": ['endpointA', 'endpointB']}

  - name: createApps
    dag:
      tasks:
      - name: operator
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "prometheus-operator", "namespace": "lma" },
                { "path": "eck-operator", "namespace": "elastic-system" },
                { "path": "fluentbit-operator", "namespace": "lma" }
              ]
        dependencies: []
      - name: logging
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "eck-resource", "namespace": "lma" },
                { "path": "fluentbit", "namespace": "lma" },
                { "path": "kubernetes-event-exporter", "namespace": "lma" }
              ]
        dependencies: [operator]
      - name: prepare-lma
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "thanos-config", "namespace": "lma" }
              ]
        dependencies: [operator]

      - name: prometheus
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "prometheus", "namespace": "lma" },
                { "path": "kube-state-metrics", "namespace": "lma" },
                { "path": "prometheus-process-exporter", "namespace": "lma" },
                { "path": "prometheus-pushgateway", "namespace": "lma" },
                { "path": "prometheus-node-exporter", "namespace": "lma" },
                { "path": "prometheus-adapter", "namespace": "lma" },
                { "path": "addons", "namespace": "lma" }
              ]
        dependencies: [prepare-lma]

      - name: federation
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "thanos", "namespace": "lma" }
              ]
        dependencies: [prometheus,logging]

      - name: grafana
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { "path": "grafana", "namespace": "lma" }
              ]
        dependencies: [federation]


  - name: collectThanosScEndpoints
    inputs:
      parameters:
      - name: tks_info_host
      - name: cluster_id
      - name: app_group_id
      - name: cur_endpoint
      env:
      - name: PYTHONPATH
        value: "/opt/protobuf/:/opt/rh/rh-python38/root/lib/python3.8/site-packages/:/opt/app-root/lib/python3.8/site-packages/"
      volumeMounts:
      - name: tks-proto-vol
        mountPath: "/opt/protobuf"
        readOnly: true
      source: |
        import subprocess
        import sys

        subprocess.check_call([sys.executable, "-m", "pip", "install",
        "grpcio", "protobuf"])

        import google.protobuf
        import grpc
        import info_pb2
        import info_pb2_grpc
        import common_pb2
        import common_pb2_grpc

        output_cluster_list = []
        inwards_endpoint_list = []
        inwards_endpoint_map = {}
        outwards_endpoint_map = {}

        ip = "{{inputs.parameters.tks_info_host}}"
        port = 9111 # if not specified
        addr = "%s:%d" % (ip, port)
        print("tks-info addr: %s" % addr)

        with grpc.insecure_channel(addr) as channel:
            cl_stub = info_pb2_grpc.ClusterInfoServiceStub(channel)
            app_stub = info_pb2_grpc.AppInfoServiceStub(channel)

            res = cl_stub.GetCluster(info_pb2.GetClusterRequest(cluster_id="{{inputs.parameters.cluster_id}}"))

            print("Response from GetCluster: ")
            print(res.cluster)
            contract_id = res.cluster.contract_id
            csp_id = res.cluster.csp_id
            cur_cluster_name = res.cluster.name

            res = cl_stub.GetClusters(info_pb2.GetClustersRequest(contract_id=contract_id, csp_id=csp_id))
            print("Response from GetClusters: ")
            print(res.clusters)

            # Iterate over cluster list except current cluster #
            for cluster in res.clusters:
                if cluster.id != "{{inputs.parameters.cluster_id}}":
                  output_cluster_list.append(cluster.id or cluster.name)
                  res = app_stub.GetAppGroupsByClusterID(common_pb2.IDRequest(id=cluster.id))
                  print("Response from GetAppGroupsByClusterID:")
                  print(res.app_groups)

                  for app_group in res.app_groups:
                    if app_group.type == common_pb2.LMA:
                      res = app_stub.GetApps(info_pb2.GetAppsRequest(app_group_id="{{inputs.parameters.app_group_id}}", type=common_pb2.PROMETHEUS))

                      # This is based on the premise that there's only one prometheus per appGroup.
                      endpoint = res.apps[0].endpoint

                      # Add this cluster's endpoint to endpoint map
                      inwards_endpoint_list.append(endpoint)

        # Update current endpoint to other cluster's site-yaml #
        outwards_endpoint_map['querier.stores'] = cur_endpoint 

        # Compose profer format to be used as input on next step 
        inwards_endpoint_map['querier.stores'] = inwards_endpoint_list
